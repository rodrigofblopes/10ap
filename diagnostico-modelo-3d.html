<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Diagn√≥stico Modelo 3D - Estrutura Completa</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            background: #1a1a1a;
            color: #00ff00;
            margin: 0;
            padding: 20px;
        }
        .header {
            background: linear-gradient(135deg, #ffd700, #ffeb3b);
            color: black;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            text-align: center;
        }
        .section {
            background: #2a2a2a;
            border: 1px solid #555;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
        }
        .analysis {
            background: #001122;
            border-left: 4px solid #00aaff;
            padding: 10px;
            margin: 10px 0;
        }
        .warning { border-left-color: #ff6600; background: #220011; }
        .error { border-left-color: #ff0000; background: #220000; }
        .success { border-left-color: #00ff00; background: #002200; }
        .info { border-left-color: #ffff00; background: #222200; }
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover { background: #45a049; }
        .data { white-space: pre-wrap; max-height: 400px; overflow-y: auto; }
        canvas { border: 2px solid #555; margin: 10px 0; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
</head>
<body>
    <div class="header">
        <h1>üîç DIAGN√ìSTICO MODELO 3D - AN√ÅLISE COMPLETA</h1>
        <p>An√°lise detalhada do arquivo 5d.glb para identificar problemas de visualiza√ß√£o</p>
    </div>

    <div class="section">
        <h2>üìã Controles de An√°lise</h2>
        <button onclick="analisarModelo()">üîç Analisar Modelo Completo</button>
        <button onclick="testarVisibilidade()">üëÅÔ∏è Testar Visibilidade de Elementos</button>
        <button onclick="analisarPosicionamento()">üìê Analisar Posicionamento</button>
        <button onclick="verificarCamadas()">üóÇÔ∏è Verificar Camadas/Cole√ß√µes</button>
        <button onclick="exportarEstrutura()">üìä Exportar Estrutura Completa</button>
    </div>

    <div id="resultados" class="section">
        <h2>üìä Resultados da An√°lise</h2>
        <div id="output">Clique em "Analisar Modelo Completo" para come√ßar...</div>
    </div>

    <div class="section">
        <h2>üéØ Visualiza√ß√£o 3D</h2>
        <canvas id="canvas3d" width="800" height="400"></canvas>
        <br>
        <button onclick="resetarCamera()">üì∑ Resetar C√¢mera</button>
        <button onclick="focarFundacao()">üèóÔ∏è Focar Funda√ß√£o</button>
        <button onclick="focarTerreo()">üè† Focar T√©rreo</button>
        <button onclick="focarSuperior()">üè¢ Focar Superior</button>
    </div>

    <script>
        let scene, camera, renderer, model;
        let modeloCarregado = false;

        // Inicializar Three.js
        function inicializarVisualizacao() {
            const canvas = document.getElementById('canvas3d');
            
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x202020);

            // Camera
            camera = new THREE.PerspectiveCamera(75, canvas.width / canvas.height, 0.1, 1000);
            camera.position.set(20, 20, 20);
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(800, 400);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            // Luzes
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(50, 50, 50);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            // Controls (b√°sico)
            canvas.addEventListener('wheel', (event) => {
                const scale = event.deltaY > 0 ? 1.1 : 0.9;
                camera.position.multiplyScalar(scale);
                render();
            });

            render();
        }

        function render() {
            renderer.render(scene, camera);
        }

        function log(message, type = 'info') {
            const output = document.getElementById('output');
            const timestamp = new Date().toLocaleTimeString();
            const classes = {
                'info': 'info',
                'warning': 'warning', 
                'error': 'error',
                'success': 'success'
            };
            
            output.innerHTML += `<div class="analysis ${classes[type]}">[${timestamp}] ${message}</div>`;
            output.scrollTop = output.scrollHeight;
        }

        async function analisarModelo() {
            log('üîÑ Iniciando an√°lise do modelo 5d.glb...', 'info');
            
            try {
                const loader = new THREE.GLTFLoader();
                
                loader.load('./5d.glb', 
                    function(gltf) {
                        log('‚úÖ Modelo carregado com sucesso!', 'success');
                        model = gltf.scene;
                        scene.add(model);
                        modeloCarregado = true;
                        
                        // An√°lise completa
                        analisarEstrutura(model);
                        analisarBoundingBox(model);
                        analisarMateriais(model);
                        analisarVisibilidadeGeral(model);
                        
                        render();
                    },
                    function(progress) {
                        const percentual = (progress.loaded / progress.total * 100).toFixed(1);
                        log(`üìà Progresso: ${percentual}%`, 'info');
                    },
                    function(error) {
                        log(`‚ùå Erro ao carregar modelo: ${error}`, 'error');
                    }
                );
                
            } catch (error) {
                log(`‚ùå Erro na an√°lise: ${error}`, 'error');
            }
        }

        function analisarEstrutura(modelo) {
            log('üèóÔ∏è === AN√ÅLISE DE ESTRUTURA ===', 'info');
            
            let totalMeshes = 0;
            let visibleMeshes = 0;
            let elementosPorCategoria = {
                'fundacao': 0,
                'terreo': 0,
                'superior': 0,
                'outros': 0
            };
            
            modelo.traverse((child) => {
                if (child instanceof THREE.Mesh) {
                    totalMeshes++;
                    if (child.visible) visibleMeshes++;
                    
                    // Categorizar por nome
                    const nome = child.name.toLowerCase();
                    if (nome.includes('3.') || nome.includes('fundacao') || nome.includes('fund')) {
                        elementosPorCategoria.fundacao++;
                    } else if (nome.includes('1.') || nome.includes('4.') || nome.includes('terreo')) {
                        elementosPorCategoria.terreo++;
                    } else if (nome.includes('2.') || nome.includes('5.') || nome.includes('superior')) {
                        elementosPorCategoria.superior++;
                    } else {
                        elementosPorCategoria.outros++;
                    }
                    
                    // Log dos primeiros 20 elementos
                    if (totalMeshes <= 20) {
                        log(`üì¶ Mesh ${totalMeshes}: "${child.name}" - Vis√≠vel: ${child.visible}`, 'info');
                    }
                }
            });
            
            log(`üìä Total de Meshes: ${totalMeshes}`, 'success');
            log(`üëÅÔ∏è Meshes Vis√≠veis: ${visibleMeshes}`, visibleMeshes === totalMeshes ? 'success' : 'warning');
            log(`üèóÔ∏è Funda√ß√£o: ${elementosPorCategoria.fundacao} elementos`, 'info');
            log(`üè† T√©rreo: ${elementosPorCategoria.terreo} elementos`, 'info');
            log(`üè¢ Superior: ${elementosPorCategoria.superior} elementos`, 'info');
            log(`‚ùì Outros: ${elementosPorCategoria.outros} elementos`, 'info');
            
            // Verificar se s√≥ tem funda√ß√£o vis√≠vel
            if (elementosPorCategoria.fundacao > 0 && 
                elementosPorCategoria.terreo === 0 && 
                elementosPorCategoria.superior === 0) {
                log('‚ö†Ô∏è PROBLEMA DETECTADO: Apenas elementos de funda√ß√£o encontrados!', 'warning');
                log('üí° Poss√≠veis causas: Modelo incompleto, elementos ocultos, ou problema de escala', 'warning');
            }
        }

        function analisarBoundingBox(modelo) {
            log('üìê === AN√ÅLISE DE DIMENS√ïES ===', 'info');
            
            const box = new THREE.Box3().setFromObject(modelo);
            const size = box.getSize(new THREE.Vector3());
            const center = box.getCenter(new THREE.Vector3());
            
            log(`üìè Dimens√µes: ${size.x.toFixed(2)} x ${size.y.toFixed(2)} x ${size.z.toFixed(2)}`, 'info');
            log(`üéØ Centro: (${center.x.toFixed(2)}, ${center.y.toFixed(2)}, ${center.z.toFixed(2)})`, 'info');
            
            // Verificar se o modelo est√° muito pequeno ou muito grande
            const maxDimension = Math.max(size.x, size.y, size.z);
            if (maxDimension < 1) {
                log('‚ö†Ô∏è PROBLEMA: Modelo muito pequeno (< 1 unidade)', 'warning');
                log('üí° Solu√ß√£o: Aumentar escala ou ajustar c√¢mera', 'warning');
            } else if (maxDimension > 1000) {
                log('‚ö†Ô∏è PROBLEMA: Modelo muito grande (> 1000 unidades)', 'warning');
                log('üí° Solu√ß√£o: Reduzir escala ou ajustar c√¢mera', 'warning');
            } else {
                log('‚úÖ Dimens√µes adequadas para visualiza√ß√£o', 'success');
            }
        }

        function analisarMateriais(modelo) {
            log('üé® === AN√ÅLISE DE MATERIAIS ===', 'info');
            
            const materiais = new Set();
            modelo.traverse((child) => {
                if (child instanceof THREE.Mesh && child.material) {
                    materiais.add(child.material.type);
                }
            });
            
            log(`üé® Tipos de materiais encontrados: ${Array.from(materiais).join(', ')}`, 'info');
        }

        function analisarVisibilidadeGeral(modelo) {
            log('üëÅÔ∏è === AN√ÅLISE DE VISIBILIDADE ===', 'info');
            
            let elementosOcultos = [];
            modelo.traverse((child) => {
                if (child instanceof THREE.Mesh && !child.visible) {
                    elementosOcultos.push(child.name);
                }
            });
            
            if (elementosOcultos.length > 0) {
                log(`‚ö†Ô∏è ${elementosOcultos.length} elementos est√£o ocultos:`, 'warning');
                elementosOcultos.slice(0, 10).forEach(nome => {
                    log(`   - ${nome}`, 'warning');
                });
                if (elementosOcultos.length > 10) {
                    log(`   ... e mais ${elementosOcultos.length - 10} elementos`, 'warning');
                }
            } else {
                log('‚úÖ Todos os elementos est√£o vis√≠veis', 'success');
            }
        }

        function testarVisibilidade() {
            if (!modeloCarregado) {
                log('‚ùå Modelo n√£o carregado. Execute "Analisar Modelo" primeiro.', 'error');
                return;
            }
            
            log('üîÑ Testando visibilidade de todas as categorias...', 'info');
            
            // Tornar todos vis√≠veis primeiro
            model.traverse((child) => {
                if (child instanceof THREE.Mesh) {
                    child.visible = true;
                }
            });
            
            log('‚úÖ Todos os elementos tornados vis√≠veis', 'success');
            render();
        }

        function resetarCamera() {
            camera.position.set(20, 20, 20);
            camera.lookAt(0, 0, 0);
            render();
        }

        function focarFundacao() {
            camera.position.set(20, 5, 20);
            camera.lookAt(0, -5, 0);
            render();
        }

        function focarTerreo() {
            camera.position.set(20, 10, 20);
            camera.lookAt(0, 5, 0);
            render();
        }

        function focarSuperior() {
            camera.position.set(20, 20, 20);
            camera.lookAt(0, 15, 0);
            render();
        }

        function exportarEstrutura() {
            if (!modeloCarregado) {
                log('‚ùå Modelo n√£o carregado. Execute "Analisar Modelo" primeiro.', 'error');
                return;
            }
            
            let estrutura = {
                elementos: [],
                estatisticas: {
                    totalMeshes: 0,
                    visibleMeshes: 0,
                    categorias: {}
                }
            };
            
            model.traverse((child) => {
                if (child instanceof THREE.Mesh) {
                    estrutura.elementos.push({
                        nome: child.name,
                        visivel: child.visible,
                        posicao: {
                            x: child.position.x,
                            y: child.position.y,
                            z: child.position.z
                        },
                        tipo: child.material?.type || 'unknown'
                    });
                    estrutura.estatisticas.totalMeshes++;
                    if (child.visible) estrutura.estatisticas.visibleMeshes++;
                }
            });
            
            // Download como JSON
            const dataStr = JSON.stringify(estrutura, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = 'estrutura-modelo-3d.json';
            link.click();
            
            log('‚úÖ Estrutura exportada como JSON', 'success');
        }

        // Inicializar ao carregar a p√°gina
        window.onload = function() {
            inicializarVisualizacao();
            log('üöÄ Diagn√≥stico inicializado. Pronto para an√°lise!', 'success');
        };
    </script>
</body>
</html>
